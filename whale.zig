// Whale VP8L decoder
// Copyright (c) 2023 Matej Fencl
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

// /==================\
// |   \\             |
// |   (_ )_   ___    |
// |     (__}.{____\  |
// |    _/  \_ \_     |
// \==================/

const std = @import("std");

// /===========================================================================\
// | ENTRY POINT                                                               |
// \===========================================================================/

// /===========================================================================\
// | decode                                                                    |
// |===========================================================================|
// | decodes a VP8L (Lossless WebP) bit stream into RGBA image                 |
// |===========================================================================|
// | reader  | std.io.Reader stream of bytes                                   |
// | alloc   | std.mem.Allocator used to allocate the image data               |
// | cfg     | config to disable transforms if needed                          |
// |===========================================================================|
// |         | an Image with decoded data                                      |
// | returns | (one byte per component, RGBA order, no padding/alignment)      |
// |         | allocated using allocator, caller calls .deinit()               |
// \===========================================================================/

pub fn decode(reader: anytype, alloc: Alloc, comptime cfg: Config) Image {
    return decode_image(reader, alloc, cfg);
}

// /===========================================================================\
// | specify                                                                   |
// |     .disable_predictor_transform      = true,        or                   |
// |     .disable_color_transform          = true,        or                   |
// |     .disable_subtract_green_transform = true,        or                   |
// |     .disable_index_transform          = true,                             |
// |                                                                           |
// | to exclude that transform from the code (transform becomes noop)          |
// \===========================================================================/

pub const Config = packed struct {
    disable_predictor_transform:      bool = false,
    disable_color_transform:          bool = false,
    disable_subtract_green_transform: bool = false,
    disable_index_transform:          bool = false,
};

// /===========================================================================\
// | Image structure                                                           |
// \===========================================================================/

pub const Image = struct {
    allocator: Alloc,
    data:      [*]u8,
    w:         u16,
    h:         u16,

    const Self = @This();

    // /=======================================================================\
    // | free allocated data                                                   |
    // \=======================================================================/

    pub inline fn deinit(self: *Self) void {
        const a = self.allocator;
        a.vtable.free(a.ptr, self.rgba(), 0, @returnAddress());
    }

    // /=======================================================================\
    // | number of pixels in the image                                         |
    // \=======================================================================/

    pub inline fn pixel_count(self: *const Self) u32 {
        return @as(u32, self.w) * @as(u32, self.h);
    }

    // /=======================================================================\
    // | slice of pixels                                                       |
    // \=======================================================================/

    pub inline fn pixels(self: *Self) []Pixel {
        return @as([*]Pixel, @ptrCast(self.data))[0 .. self.pixel_count()];
    }

    // /=======================================================================\
    // | const slice of pixels                                                 |
    // \=======================================================================/

    pub inline fn const_pixels(self: *const Self) []const Pixel {
        return @constCast(self).pixels();
    }

    // /=======================================================================\
    // | pixel on position x, y                                                |
    // \=======================================================================/

    pub inline fn pixel(self: *const Self, x: u16, y: u16) Pixel {
        return @as([*]Pixel, @ptrCast(self.data))[@as(u32, x) +
            @as(u32, y) * @as(u32, self.w)];
    }

    // /=======================================================================\
    // | slice of color components in RGBA order                               |
    // \=======================================================================/

    pub inline fn rgba(self: *Self) []u8 {
        return self.data[0 .. self.pixel_count() * @sizeOf(Pixel)];
    }

    // /=======================================================================\
    // | const slice of color components in RGBA order                         |
    // \=======================================================================/

    pub inline fn const_rgba(self: *const Self) []const u8 {
        return @constCast(self).rgba();
    }
};

// /===========================================================================\
// | IMPLEMENTATION                                                            |
// \===========================================================================/

const TRANSFORM_PREDICTOR = 0;
const TRANSFORM_COLOR     = 1;
const TRANSFORM_GREEN     = 2;
const TRANSFORM_INDEX     = 3;

const LITERALS_COUNT  = 256;
const LENGTHS_COUNT   = 24;
const DISTANCES_COUNT = 40;
const LENCODE_LENGTHS = 19;
const DISTMAP_COUNT   = 120;
const CACHE_SIZE_MAX  = 2048;

const LITLEN_COUNT = LITERALS_COUNT + LENGTHS_COUNT;
const MAX_SYMBOLS  = LITLEN_COUNT + CACHE_SIZE_MAX;

// /===========================================================================\
// | HELPERS                                                                   |
// \===========================================================================/

inline fn trunc(comptime T: type, v: anytype) T {
    return @truncate(@as(@Type(.{
        .Int = .{
            .signedness = @typeInfo(T).Int.signedness,
            .bits       = @typeInfo(@TypeOf(v)).Int.bits,
        },
    }), @bitCast(v)));
}

// /===========================================================================\
// | DATA TABLES                                                               |
// \===========================================================================/

const lencode_order = [_]u8 {
    17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
};

const distmap_offset = [_][2]i8 {
    .{  0, 1 }, .{  1, 0 }, .{  1, 1 }, .{ -1, 1 }, .{  0, 2 }, .{  2, 0 },
    .{  1, 2 }, .{ -1, 2 }, .{  2, 1 }, .{ -2, 1 }, .{  2, 2 }, .{ -2, 2 },
    .{  0, 3 }, .{  3, 0 }, .{  1, 3 }, .{ -1, 3 }, .{  3, 1 }, .{ -3, 1 },
    .{  2, 3 }, .{ -2, 3 }, .{  3, 2 }, .{ -3, 2 }, .{  0, 4 }, .{  4, 0 },
    .{  1, 4 }, .{ -1, 4 }, .{  4, 1 }, .{ -4, 1 }, .{  3, 3 }, .{ -3, 3 },
    .{  2, 4 }, .{ -2, 4 }, .{  4, 2 }, .{ -4, 2 }, .{  0, 5 }, .{  3, 4 },
    .{ -3, 4 }, .{  4, 3 }, .{ -4, 3 }, .{  5, 0 }, .{  1, 5 }, .{ -1, 5 },
    .{  5, 1 }, .{ -5, 1 }, .{  2, 5 }, .{ -2, 5 }, .{  5, 2 }, .{ -5, 2 },
    .{  4, 4 }, .{ -4, 4 }, .{  3, 5 }, .{ -3, 5 }, .{  5, 3 }, .{ -5, 3 },
    .{  0, 6 }, .{  6, 0 }, .{  1, 6 }, .{ -1, 6 }, .{  6, 1 }, .{ -6, 1 },
    .{  2, 6 }, .{ -2, 6 }, .{  6, 2 }, .{ -6, 2 }, .{  4, 5 }, .{ -4, 5 },
    .{  5, 4 }, .{ -5, 4 }, .{  3, 6 }, .{ -3, 6 }, .{  6, 3 }, .{ -6, 3 },
    .{  0, 7 }, .{  7, 0 }, .{  1, 7 }, .{ -1, 7 }, .{  5, 5 }, .{ -5, 5 },
    .{  7, 1 }, .{ -7, 1 }, .{  4, 6 }, .{ -4, 6 }, .{  6, 4 }, .{ -6, 4 },
    .{  2, 7 }, .{ -2, 7 }, .{  7, 2 }, .{ -7, 2 }, .{  3, 7 }, .{ -3, 7 },
    .{  7, 3 }, .{ -7, 3 }, .{  5, 6 }, .{ -5, 6 }, .{  6, 5 }, .{ -6, 5 },
    .{  8, 0 }, .{  4, 7 }, .{ -4, 7 }, .{  7, 4 }, .{ -7, 4 }, .{  8, 1 },
    .{  8, 2 }, .{  6, 6 }, .{ -6, 6 }, .{  8, 3 }, .{  5, 7 }, .{ -5, 7 },
    .{  7, 5 }, .{ -7, 5 }, .{  8, 4 }, .{  6, 7 }, .{ -6, 7 }, .{  7, 6 },
    .{ -7, 6 }, .{  8, 5 }, .{  7, 7 }, .{ -7, 7 }, .{  8, 6 }, .{  8, 7 },
};

// /===========================================================================\
// | PIXEL                                                                     |
// \===========================================================================/

pub const Pixel = extern struct {
    r: u8 = 0,
    g: u8 = 0,
    b: u8 = 0,
    a: u8 = 0,

    const Self = @This();

    inline fn hash(self: Self, bits: u6) u32 {
        return 0x1e35a7bd *%       (
            @as(u32, self.b)       |
            @as(u32, self.g) << 8  |
            @as(u32, self.r) << 16 |
            @as(u32, self.a) << 24 )
                >> trunc(u5, 32 - bits);
    }

    inline fn add(self: *Self, px: Self) void {
        self.r +%= px.r;
        self.g +%= px.g;
        self.b +%= px.b;
        self.a +%= px.a;
    }

    inline fn addget(self: *Self, px: Self) Self {
        self.add(px); return self.*;
    }

    inline fn avg(self: Self, px: Self) Self {
        return .{
            .r = trunc(u8, @as(u16, self.r) + px.r >> 1),
            .g = trunc(u8, @as(u16, self.g) + px.g >> 1),
            .b = trunc(u8, @as(u16, self.b) + px.b >> 1),
            .a = trunc(u8, @as(u16, self.a) + px.a >> 1),
        };
    }

    inline fn clamp(v: i16) u8 {
        return trunc(u8, @max(0, @min(v, 255)));
    }

    inline fn clamp_add_sub(a: Self, b: Self, c: Self) Self {
        return .{
            .r = clamp(@as(i16, a.r) + b.r - c.r),
            .g = clamp(@as(i16, a.g) + b.g - c.g),
            .b = clamp(@as(i16, a.b) + b.b - c.b),
            .a = clamp(@as(i16, a.a) + b.a - c.a),
        };
    }

    inline fn clamp_add_sub_half(a: Self, b: Self) Self {
        return .{
            .r = clamp(a.r + @divTrunc(@as(i16, a.r) - b.r, 2)),
            .g = clamp(a.g + @divTrunc(@as(i16, a.g) - b.g, 2)),
            .b = clamp(a.b + @divTrunc(@as(i16, a.b) - b.b, 2)),
            .a = clamp(a.a + @divTrunc(@as(i16, a.a) - b.a, 2)),
        };
    }

    inline fn rg(self: Self) u16 {
        return @as(u16, self.r) << 8 | self.g;
    }
};

// /===========================================================================\
// | HUFFMAN CODES                                                             |
// \===========================================================================/

const Code = struct {
    tree: []Node,
    size: u16,
    u: union {
        symbol: [2]u8,
        root:   u16,
    },

    const Self = @This();
    const Node = struct { child: [2]u16 = .{ 0, 0 } };

    fn read(self: *const Self, ctx: Context) u16 {
        return switch (self.size) {
            0 => 0,
            1 => self.u.symbol[0],
            2 => self.u.symbol[ctx.read(u1, 1)],
            else => |size| blk: {
                const tree = self.tree;
                var index = self.u.root; while (index >= size)
                    index = tree[index - size].child[ctx.read(u1, 1)];
                break :blk index;
            }
        };
    }

    inline fn insert(self: *Self, sym: u16, word: u16, l: u8, cap: u16) u16 {
        const tree = self.tree;
        const size = self.size;

        var pointer = &self.u.root;
        var used    = cap + size;

        for (1 .. l + 1) |i| {
            var index = pointer.*;
            if (index < size) {
                index     = used;
                pointer.* = index;
                used     += 1;
            }

            pointer = &tree[index - size].child[word >> trunc(u4, l - i) & 1];
        }

        pointer.* = sym;
        return used - size;
    }

    fn init_cannonical(ctx: Context, lens: []const u8, space: ?[]Node) Self {
        var base = [_]u16 { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
        var symcount: u16 = 0;

        for (lens) |len| if (len > 0) {
            base[len - 1] += 1;
            symcount += 1;
        };

        var accum: u16 = 0; for (&base) |*cbase| {
            const c = cbase.*;
            cbase.* = accum;
            accum = accum + c << 1;
        }

        const tree = space orelse ctx.alloc(Node, symcount - 1);

        var self = Self {
            .size = trunc(u16, lens.len),
            .u = .{ .root = 0 },
            .tree = tree,
        };

        for (tree[0 .. symcount - 1]) |*node| node.* = .{};

        var used: u16 = 0; for (lens, 0 ..) |len, sym| if (len > 0) {
            const word = &base[len - 1];
            used = self.insert(trunc(u16, sym), word.*, len, used);
            word.* += 1;
        };

        return self;
    }

    inline fn init_simple(ctx: Context) Self {
        const two_symbols = ctx.read(u2, 1); return Self {
            .size = two_symbols + 1,
            .u = .{
                .symbol = .{
                    ctx.read(u8, ctx.read(u4, 1) * 7 + 1),
                    if (two_symbols == 1) ctx.read(u8, 8) else 0,
                },
            },
            .tree = undefined,
        };
    }

    inline fn init_complex(ctx: Context, size: u16) Self {
        var lens: [LENCODE_LENGTHS    ]u8   = undefined;
        var tree: [LENCODE_LENGTHS - 1]Node = undefined;

        const lencode_read = ctx.read(u8, 4) + 4;
        for (0 .. LENCODE_LENGTHS) |i| lens[lencode_order[i]] =
            if (i < lencode_read) ctx.read(u8, 3) else 0;

        var limit = switch (ctx.read(u1, 1)) {
            0 => size, 1 => ctx.read(u16, ctx.read(u5, 3) * 2 + 2) + 2,
        };

        const lencode = Self.init_cannonical(ctx, &lens, &tree);

        var code_lens: [MAX_SYMBOLS]u8 = undefined;

        var code_count: u16 = 0;
        var prev:       u8  = 8;
        var repeat_c:   u8  = undefined;
        var repeat:     u8  = undefined;

        while (code_count < size and limit > 0) : (limit -= 1) {
            switch (trunc(u8, lencode.read(ctx))) {
                0 ... 15 => |len| {
                    if (len > 0) prev = len;
                    code_lens[code_count] = len;
                    code_count += 1;
                    continue;
                },

                16 => { repeat_c = ctx.read(u8, 2) + 3;  repeat = prev; },
                17 => { repeat_c = ctx.read(u8, 3) + 3;  repeat = 0; },
                18 => { repeat_c = ctx.read(u8, 7) + 11; repeat = 0; },
                else => {},
            }

            while (repeat_c > 0) : ({ repeat_c -= 1; code_count += 1; })
                code_lens[code_count] = repeat;
        }

        return Self.init_cannonical(ctx, code_lens[0 .. code_count], null);
    }

    fn init(ctx: Context, size: u16) Self {
        return switch (ctx.read(u1, 1)) {
            0 => Self.init_complex(ctx, size),
            1 => Self.init_simple(ctx),
        };
    }
};

const Group = struct {
    code: [5]Code,

    const Self = @This();

    inline fn read(self: *const Self, ctx: Context, code: u8) u16 {
        return self.code[code].read(ctx);
    }

    inline fn init(ctx: Context, cache: Cache) Self {
        return .{ .code = .{
            Code.init(ctx, LITLEN_COUNT + cache.size()),
            Code.init(ctx, LITERALS_COUNT),
            Code.init(ctx, LITERALS_COUNT),
            Code.init(ctx, LITERALS_COUNT),
            Code.init(ctx, DISTANCES_COUNT),
        }};
    }
};

// /===========================================================================\
// | CACHE                                                                     |
// \===========================================================================/

const Cache = struct {
    cache: [*]Pixel,
    bits:  u4,

    const Self = @This();

    inline fn size(self: *const Self) u16 {
        return if (self.bits > 0) @as(u16, 1) << self.bits else 0;
    }

    inline fn data(self: *Self) []Pixel {
        return self.cache[0 .. self.size()];
    }

    inline fn init(ctx: Context) Self {
        var self: Self = undefined;
        self.bits  = if (ctx.read(u1, 1) == 1) ctx.read(u4, 4) else 0;
        self.cache = if (self.bits == 0) undefined else
            ctx.alloc(Pixel, self.size()).ptr;

        for (self.data()) |*c| c.* = .{};
        return self;
    }

    inline fn put(self: *Self, color: Pixel) Pixel {
        if (self.bits > 0) self.cache[color.hash(self.bits)] = color;
        return color;
    }

    inline fn get(self: Self, code: u16) Pixel {
        return self.cache[code - LITLEN_COUNT];
    }
};

// /===========================================================================\
// | GENERAL IMAGE DECODING                                                    |
// \===========================================================================/

const Bitmap = struct {
    data: [*]Pixel = undefined,
    w:    u16      = undefined,
    h:    u16      = undefined,
    bits: u4       = 0,

    const Self = @This();

    inline fn size(self: *const Self) u32 {
        return @as(u32, self.w) * @as(u32, self.h);
    }

    inline fn pixels(self: *const Self) []Pixel {
        return self.data[0 .. self.size()];
    }

    inline fn pixel(self: *const Self, x: u16, y: u16) Pixel {
        const b = self.bits;
        return self.data[@as(u32, x >> b) + @as(u32, y >> b) * self.w];
    }

    fn lendist(ctx: Context, code: u16) u32 {
        if (code < 4) return code;
        const extra = trunc(u5, (code - 2) >> 1);
        return (@as(u32, 2 + (code & 1)) << extra) + ctx.read(u18, extra);
    }

    fn alloc(self: *Self, ctx: Context, w: u16, h: u16, bits: u4) void {
        self.data = ctx.alloc(Pixel, @as(u32, w) * @as(u32, h)).ptr;
        self.w = w;
        self.h = h;
        self.bits = bits;
    }

    fn decode(self: *Self, ctx: Context, main: bool, w: u16, h: u16) void {
        const dsize = @as(u32, w) * h;
        var cache = Cache.init(ctx);

        var max_group: u16 = 0;

        var entropy = Bitmap {};
        if (main and ctx.read(u1, 1) == 1) {
            entropy.block_alloc_decode(ctx, w, h);
            for (entropy.pixels()) |px|
                max_group = @max(px.rg(), max_group);
        }

        const groupc = max_group + 1;

        var single_group: Group = undefined;
        var groups = if (groupc > 1) ctx.alloc(Group, groupc)
            else @as([*]Group, @ptrCast(&single_group))[0 .. 1];

        for (groups) |*g| g.* = Group.init(ctx, cache);

        var r: u32 = 0;
        var d: u32 = undefined;

        for (self.data, 0 .. dsize) |*px, i| {
            const ppx: [*]Pixel = @ptrCast(px);
            px.* = if (r > 0) blk: {
                r -= 1;
                break :blk cache.put((ppx - d)[0]);
            } else blk: {
                const group = &groups[if (entropy.bits == 0) 0
                    else entropy.pixel(trunc(u16, i % w), trunc(u16, i / w))
                        .rg()];

                const code = group.read(ctx, 0);

                break :blk if (code < LITERALS_COUNT) cache.put(.{
                    .r = trunc(u8, group.read(ctx, 1)),
                    .g = trunc(u8, code),
                    .b = trunc(u8, group.read(ctx, 2)),
                    .a = trunc(u8, group.read(ctx, 3)),
                }) else if (code < LITLEN_COUNT) {
                    r = lendist(ctx, code - LITERALS_COUNT);
                    const distance = lendist(ctx, group.read(ctx, 4));
                    d = @bitCast(@max(1, if (distance < DISTMAP_COUNT)
                        @as(i32, distmap_offset[distance][0]) +
                        @as(i32, distmap_offset[distance][1]) * w
                            else @as(i32, @bitCast(distance))
                                - DISTMAP_COUNT + 1));
                    break :blk cache.put((ppx - d)[0]);
                } else cache.get(code);
            };
        }
    }

    fn block_alloc_decode(self: *Self, ctx: Context, w: u16, h: u16) void {
        const bits       = ctx.read(u4, 3) + 2;
        const block_size = @as(u32, 1) << bits;
        const block_w    = trunc(u16, (w + block_size - 1) / block_size);
        const block_h    = trunc(u16, (h + block_size - 1) / block_size);

        self.alloc(ctx, block_w, block_h, bits);
        self.decode(ctx, false, block_w, block_h);
    }
};

// /===========================================================================\
// | PREDICTOR TRANSFORM                                                       |
// \===========================================================================/

fn PredictorTransform(comptime enable: bool) type {
    return if (enable) struct {
        bitmap: Bitmap,

        const Self = @This();

        inline fn decode(self: *Self, ctx: Context, w: u16, h: u16) void {
            self.bitmap.block_alloc_decode(ctx, w, h);
        }

        fn dist(c1: u8, c2: u8) i16 {
            const dst = @as(i16, c1) - @as(i16, c2);
            return if (dst >= 0) dst else -dst;
        }

        const Neighbours = struct {
            a: *Pixel,
            b: *Pixel,
            c: *Pixel,
            d: *Pixel,
        };

        inline fn apply_one(t: u8, p: *Pixel, s: Neighbours) void {
            switch (t) {
                0 => p.a +%= 255,
                1 => p.add(s.a.*),
                2 => p.add(s.c.*),
                3 => p.add(s.d.*),
                4 => p.add(s.b.*),
                5 => p.add(s.a.avg(s.d.*).avg(s.c.*)),
                6 => p.add(s.a.avg(s.b.*)),
                7 => p.add(s.a.avg(s.c.*)),
                8 => p.add(s.c.avg(s.b.*)),
                9 => p.add(s.c.avg(s.d.*)),
                10 => p.add(s.a.avg(s.b.*).avg(s.c.avg(s.d.*))),
                11 => p.add(if (
                    dist(s.a.r, s.b.r) - dist(s.c.r, s.b.r) +
                    dist(s.a.g, s.b.g) - dist(s.c.g, s.b.g) +
                    dist(s.a.b, s.b.b) - dist(s.c.b, s.b.b) +
                    dist(s.a.a, s.b.a) - dist(s.c.a, s.b.a) > 0)
                        s.a.* else s.c.*),
                12 => p.add(s.a.clamp_add_sub(s.c.*, s.b.*)),
                13 => p.add(s.a.avg(s.c.*).clamp_add_sub_half(s.b.*)),
                else => {},
            }
        }

        inline fn apply(self: Self, bitmap: *Bitmap) void {
            const w    = bitmap.w;
            const bmp  = self.bitmap;
            const data = bitmap.data;

            for (data, 0 .. bitmap.size()) |*px, i| apply_one(switch (i / w) {
                0 => switch (i % w) { 0 => 0, else => 1 },
                else => |y| switch (i % w) { 0 => 2,
                    else => |x| bmp.pixel(trunc(u16, x), trunc(u16, y)).g,
                },
            }, px, Neighbours {
                .a = @ptrCast(data + i - 1),
                .b = @ptrCast(data + i - w - 1),
                .c = @ptrCast(data + i - w),
                .d = @ptrCast(data + i - w + 1),
            });
        }
    } else struct {
        const Self = @This();
        inline fn decode(_: *Self, _: Context, _: u16, _: u16) void {}
        inline fn apply(_: Self, _: *Bitmap) void {}
    };
}

// /===========================================================================\
// | COLOR TRANSFORM                                                           |
// \===========================================================================/

fn ColorTransform(comptime enable: bool) type {
    return if (enable) struct {
        bitmap: Bitmap,

        const Self = @This();

        inline fn decode(self: *Self, ctx: Context, w: u16, h: u16) void {
            self.bitmap.block_alloc_decode(ctx, w, h);
        }

        inline fn delta(c1: u8, c2: u8) u8 {
            return trunc(u8,
                @as(i16, @as(i8, @bitCast(c1))) *
                @as(i16, @as(i8, @bitCast(c2))) >> 5);
        }

        inline fn apply(self: Self, bitmap: *Bitmap) void {
            const w   = bitmap.w;
            const bmp = self.bitmap;

            for (bitmap.pixels(), 0 ..) |*px, i| {
                const cpx = bmp.pixel(trunc(u16, i % w), trunc(u16, i / w));
                px.r +%= delta(cpx.b, px.g);
                px.b +%= delta(cpx.g, px.g) +% delta(cpx.r, px.r);
            }
        }
    } else struct {
        const Self = @This();
        inline fn decode(_: *Self, _: Context, _: u16, _: u16) void {}
        inline fn apply(_: Self, _: *Bitmap) void {}
    };
}

// /===========================================================================\
// | SUBTRACT GREEN TRANSFORM                                                  |
// \===========================================================================/

fn apply_subtract_green(comptime enable: bool, bitmap: *Bitmap) void {
    if (enable) for (bitmap.pixels()) |*px| { px.r +%= px.g; px.b +%= px.g; };
}

// /===========================================================================\
// | INDEX TRANSFORM                                                           |
// \===========================================================================/

fn IndexTransform(comptime enable: bool) type {
    return if (enable) struct {
        bitmap: Bitmap,

        const Self = @This();

        inline fn decode(self: *Self, ctx: Context) u4 {
            const c = ctx.read(u8, 8);
            const size = @as(u16, c) + 1;
            self.bitmap.alloc(ctx, size, 1, switch (c / 2) {
                0 => 3, 1 => 2, 2 ... 7 => 1, else => 0,
            });
            self.bitmap.decode(ctx, false, size, 1);
            var p = Pixel {};
            for (self.bitmap.pixels()) |*px| p = px.addget(p);
            return self.bitmap.bits;
        }

        inline fn apply(self: Self, bitmap: *Bitmap) void {
            const ind = self.bitmap.pixels();
            const len = self.bitmap.w;
            const b   = trunc(u2, self.bitmap.bits);
            const fw  = @as(u32, bitmap.w);
            const h   = @as(u32, bitmap.h);
            const w   = @as(u32, fw >> b);
            const rb  = 3 - b;
            const out = bitmap.pixels();

            const msk: u8 = switch (b) { 0 => 255, 1 => 15, 2 => 3, 3 => 1 };
            const mod: u3 = switch (b) { 0 => 0,   1 => 1,  2 => 3, 3 => 7 };

            for (1 .. h + 1) |y| {
                for (1 .. fw + 1) |x| {
                    const rx = fw - x;
                    const ry = h  - y;
                    const i = out[ry * w + (rx >> b)].g >>
                        trunc(u3, (rx & mod) << rb) & msk;

                    out[ry * fw + rx] = if (i <= len) ind[i] else .{};
                }
            }
        }
    } else struct {
        const Self = @This();
        inline fn decode(_: *Self, _: Context) u4 { return 0; }
        inline fn apply(_: Self, _: *Bitmap) void {}
    };
}

// /===========================================================================\
// | CONTEXT                                                                   |
// \===========================================================================/

const Alloc = std.mem.Allocator;

const ReadFn  = *const fn (n: u8,           provider: *anyopaque) u32;
const AllocFn = *const fn (s: usize, a: u8, provider: *anyopaque) *anyopaque;

const Context = struct {
    provider: *anyopaque,
    read_fn:   ReadFn,
    alloc_fn:  AllocFn,

    const Self = @This();

    inline fn read(self: Self, comptime T: type, n: u5) T {
        return trunc(T, self.read_fn(n, self.provider));
    }

    inline fn alloc(self: Self, comptime T: type, n: usize) []T {
        const a = @alignOf(T);
        return @as([*]T, @ptrCast(@alignCast(self.alloc_fn(
            @sizeOf(T) * n, std.math.log2(a), self.provider))))[0 .. n];
    }

    inline fn decode(ctx: Context, a: Alloc, comptime cfg: Config) Bitmap {
        const w = ctx.read(u16, 14) + 1;
        const h = ctx.read(u16, 14) + 1;
        _ = ctx.read(u4, 4);

        var cw = w;

        var rgba = Bitmap {
            .data = @ptrCast(a.vtable.alloc(a.ptr,
                @as(usize, w) * h * @sizeOf(Pixel), 0, @returnAddress())
                    orelse undefined),

            .w    = w,
            .h    = h,
            .bits = 0,
        };

        var list:  u8 = 0;
        var count: u8 = 0;

        const enable_transform = !cfg.disable_predictor_transform;
        const enable_color     = !cfg.disable_color_transform;
        const enable_green     = !cfg.disable_subtract_green_transform;
        const enable_index     = !cfg.disable_index_transform;

        var predictor: PredictorTransform(enable_transform) = undefined;
        var color:     ColorTransform(enable_color)         = undefined;
        var index:     IndexTransform(enable_index)         = undefined;

        while (ctx.read(u1, 1) == 1) : (count += 1) {
            const t = ctx.read(u2, 2);
            switch (t) {
                TRANSFORM_PREDICTOR => predictor.decode(ctx, cw, h),
                TRANSFORM_COLOR     => color.decode(ctx, cw, h),
                TRANSFORM_INDEX     => cw >>= index.decode(ctx),
                else                => {},
            } list = list << 2 | t;
        }

        rgba.decode(ctx, true, cw, h);

        while (count > 0) : ({ count -= 1; list >>= 2; }) switch (list & 3) {
            TRANSFORM_PREDICTOR => predictor.apply(&rgba),
            TRANSFORM_COLOR     => color.apply(&rgba),
            TRANSFORM_GREEN     => apply_subtract_green(enable_green, &rgba),
            TRANSFORM_INDEX     => index.apply(&rgba),
            else                => {},
        };

        return rgba;
    }
};

// /===========================================================================\
// | DECODER                                                                   |
// \===========================================================================/

fn decode_image(reader: anytype, allocator: Alloc, comptime cfg: Config) Image {
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit();

    const Reader = @TypeOf(reader);

    const Provider = struct {
        buf:    [buf_bytes]u8,
        len:    u16,
        reader: Reader,
        alloc:  Alloc,

        const Self = @This();

        const buf_bytes = 4096;
        const buf_bits = buf_bytes * 8;

        inline fn readBit(self: *Self) u32 {
            if (self.len == 0) {
                _ = self.reader.read(self.buf[0 .. buf_bytes]) catch 0;
                self.len = buf_bits;
            }

            const byte = &self.buf[buf_bits - self.len >> 3];
            const out = byte.* & 1;
            self.len -= 1;
            byte.* >>= 1;
            return out;
        }

        fn read_fn(n: u8, ctx: *anyopaque) u32 {
            const self: *Self = @ptrCast(@alignCast(ctx));
            var out: u32 = 0;
            for (0 .. n) |i|
                out |= self.readBit() << trunc(u5, i);
            return out;
        }

        fn alloc_fn(s: usize, a: u8, ctx: *anyopaque) *anyopaque {
            const self: *Self = @ptrCast(@alignCast(ctx));
            const alloc = self.alloc;
            return @ptrCast(alloc.vtable.alloc(
                alloc.ptr, s, a, @returnAddress())
                    orelse undefined);
        }
    };

    var provider = Provider {
        .buf    = undefined,
        .len    = 0,
        .reader = reader,
        .alloc  = arena.allocator(),
    };

    const bitmap = Context.decode(.{
        .provider = &provider,
        .read_fn  = &Provider.read_fn,
        .alloc_fn = &Provider.alloc_fn,
    }, allocator, cfg);

    return .{
        .data      = @ptrCast(bitmap.data),
        .w         = bitmap.w,
        .h         = bitmap.h,
        .allocator = allocator,
    };
}
