/* Whale VP8L decoder
 * Copyright (c) 2023 Matej Fencl
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/*  /==================\
 *  |   \\             |
 *  |   (_ )_   ___    |
 *  |     (__}.{____\  |
 *  |    _/  \_ \_     |
 *  \==================/
 */

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>

enum {
    VP8L_TRANSFORM_PREDICTOR = 0,
    VP8L_TRANSFORM_COLOR     = 1,
    VP8L_TRANSFORM_GREEN     = 2,
    VP8L_TRANSFORM_INDEX     = 3,

    VP8L_LITERALS_COUNT  = 256,
    VP8L_LENGTHS_COUNT   = 24,
    VP8L_DISTANCES_COUNT = 40,
    VP8L_LENCODE_LENGTHS = 19,
    VP8L_OFFSET_COUNT    = 120,
    VP8L_CACHE_SIZE_MAX  = 2048,

    VP8L_LITLEN_COUNT = VP8L_LITERALS_COUNT + VP8L_LENGTHS_COUNT,
    VP8L_MAX_SYMBOLS  = VP8L_LITLEN_COUNT + VP8L_CACHE_SIZE_MAX,
};

typedef uint8_t        vp8l_byte_t;
typedef uint_fast32_t  vp8l_size_t;
typedef int_fast32_t   vp8l_diff_t;
typedef uint_least16_t vp8l_code_word_t;

typedef struct vp8l_code_node { vp8l_code_word_t child[2]; } vp8l_code_node_t;

typedef struct vp8l_code {
    vp8l_code_word_t size;
    union {
        vp8l_byte_t symbol[2];
        vp8l_code_word_t root;
    } u;
    vp8l_code_node_t *tree;
} *vp8l_code_t;

typedef struct vp8l_group { struct vp8l_code code[5]; } *vp8l_group_t;

typedef struct vp8l_context {
    void           *u;
    unsigned long (*read)  (unsigned char n, void *user_data);
    void*         (*alloc) (unsigned long n, void *user_data);
    void          (*free)  (void     *block, void *user_data);
} *vp8l_context_t;

typedef struct vp8l_pixel { vp8l_byte_t r, g, b, a; } vp8l_pixel_t;

/* /===========================================================================\
 * | DATA TABLES                                                               |
 * \===========================================================================/
 */

static const vp8l_byte_t vp8l_lencode_order[VP8L_LENCODE_LENGTHS] = {
    17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
};

static const signed char vp8l_offsets[VP8L_OFFSET_COUNT][2] = {
    {  0, 1 }, {  1, 0 }, {  1, 1 }, { -1, 1 }, {  0, 2 }, {  2, 0 },
    {  1, 2 }, { -1, 2 }, {  2, 1 }, { -2, 1 }, {  2, 2 }, { -2, 2 },
    {  0, 3 }, {  3, 0 }, {  1, 3 }, { -1, 3 }, {  3, 1 }, { -3, 1 },
    {  2, 3 }, { -2, 3 }, {  3, 2 }, { -3, 2 }, {  0, 4 }, {  4, 0 },
    {  1, 4 }, { -1, 4 }, {  4, 1 }, { -4, 1 }, {  3, 3 }, { -3, 3 },
    {  2, 4 }, { -2, 4 }, {  4, 2 }, { -4, 2 }, {  0, 5 }, {  3, 4 },
    { -3, 4 }, {  4, 3 }, { -4, 3 }, {  5, 0 }, {  1, 5 }, { -1, 5 },
    {  5, 1 }, { -5, 1 }, {  2, 5 }, { -2, 5 }, {  5, 2 }, { -5, 2 },
    {  4, 4 }, { -4, 4 }, {  3, 5 }, { -3, 5 }, {  5, 3 }, { -5, 3 },
    {  0, 6 }, {  6, 0 }, {  1, 6 }, { -1, 6 }, {  6, 1 }, { -6, 1 },
    {  2, 6 }, { -2, 6 }, {  6, 2 }, { -6, 2 }, {  4, 5 }, { -4, 5 },
    {  5, 4 }, { -5, 4 }, {  3, 6 }, { -3, 6 }, {  6, 3 }, { -6, 3 },
    {  0, 7 }, {  7, 0 }, {  1, 7 }, { -1, 7 }, {  5, 5 }, { -5, 5 },
    {  7, 1 }, { -7, 1 }, {  4, 6 }, { -4, 6 }, {  6, 4 }, { -6, 4 },
    {  2, 7 }, { -2, 7 }, {  7, 2 }, { -7, 2 }, {  3, 7 }, { -3, 7 },
    {  7, 3 }, { -7, 3 }, {  5, 6 }, { -5, 6 }, {  6, 5 }, { -6, 5 },
    {  8, 0 }, {  4, 7 }, { -4, 7 }, {  7, 4 }, { -7, 4 }, {  8, 1 },
    {  8, 2 }, {  6, 6 }, { -6, 6 }, {  8, 3 }, {  5, 7 }, { -5, 7 },
    {  7, 5 }, { -7, 5 }, {  8, 4 }, {  6, 7 }, { -6, 7 }, {  7, 6 },
    { -7, 6 }, {  8, 5 }, {  7, 7 }, { -7, 7 }, {  8, 6 }, {  8, 7 },
};

/* /===========================================================================\
 * | HUFFMAN CODES                                                             |
 * \===========================================================================/
 */

static inline void vp8l_code_insert(
    vp8l_code_node_t *tree,
    vp8l_code_word_t *root,
    vp8l_code_word_t  size,
    vp8l_code_word_t  symbol,
    vp8l_code_word_t  word,
    vp8l_code_word_t *used,
    vp8l_byte_t       length) {

    while (length) {
        vp8l_code_word_t index = *root;
        vp8l_code_node_t *node = index < size
            ? tree + ((*root = (*used)++) - size)
            : tree + (index - size);

        root = &node->child[word >> --length & 1];
    } *root = symbol;
}

static vp8l_code_word_t vp8l_code_read(vp8l_context_t ctx, vp8l_code_t code) {
    vp8l_code_node_t *tree = code->tree;
    vp8l_code_word_t  size = code->size;

    if (tree) {
        vp8l_code_word_t index = code->u.root;
        while (index >= size) {
            index = tree[index - size].child[ctx->read(1, ctx->u)];
        } return index;
    } else return code->u.symbol[size < 2 ? 0 : ctx->read(1, ctx->u)];
}

static void vp8l_cannonical_code(
    vp8l_context_t    ctx,
    vp8l_byte_t      *lengths,
    vp8l_code_word_t  size,
    vp8l_code_t       code,
    vp8l_code_node_t *treemem) {

    vp8l_code_word_t base[16] = {0};
    vp8l_code_word_t real_size = 0;

    for (vp8l_code_word_t i = 0; i < size; ++i) {
        vp8l_byte_t length = lengths[i];
        if (length > 0) ++base[length - 1], ++real_size;
    } --real_size;

    vp8l_code_word_t current_base = 0;
    for (vp8l_byte_t i = 0; i < 16; ++i) {
        vp8l_code_word_t c = base[i];
        base[i] = current_base;
        current_base = (current_base + c) << 1;
    }

    vp8l_code_node_t *tree = treemem ? treemem : (vp8l_code_node_t*)
        ctx->alloc(sizeof(vp8l_code_node_t) * real_size, ctx->u);

    for (vp8l_code_node_t *i = tree, *e = i + real_size; i < e; ++i) {
        i->child[0] = 0, i->child[1] = 0;
    }

    vp8l_code_word_t root = 0;
    vp8l_code_word_t used = size;

    for (vp8l_code_word_t i = 0, l; i < size; ++i) {
        if ((l = lengths[i]) > 0) vp8l_code_insert(tree, &root,
            size, i, base[l - 1]++, &used, l);
    }

    code->size = size;
    code->tree = tree;
    code->u.root = root;
}

static void vp8l_simple_code_decode(vp8l_context_t ctx, vp8l_code_t code) {
    vp8l_byte_t two_symbols = ctx->read(1, ctx->u);
    code->tree        = 0;
    code->size        = two_symbols + 1;
    code->u.symbol[0] = ctx->read(1 + ctx->read(1, ctx->u) * 7, ctx->u);
    code->u.symbol[1] = two_symbols ? ctx->read(8, ctx->u) : 0;
}

static void vp8l_complex_code_decode(
    vp8l_context_t   ctx,
    vp8l_code_t      code,
    vp8l_code_word_t size) {

    vp8l_byte_t      lencode_lengths[VP8L_LENCODE_LENGTHS];
    vp8l_code_node_t lencode_treemem[VP8L_LENCODE_LENGTHS - 1];

    vp8l_byte_t lencode_read = ctx->read(4, ctx->u) + 4;
    for (vp8l_byte_t i = 0; i < VP8L_LENCODE_LENGTHS; ++i)
        lencode_lengths[vp8l_lencode_order[i]] = i < lencode_read
            ? ctx->read(3, ctx->u) : 0;

    vp8l_code_word_t limit = !ctx->read(1, ctx->u) ? size
        : ctx->read(ctx->read(3, ctx->u) * 2 + 2, ctx->u) + 2;

    struct vp8l_code lc, *lencode = &lc;
    vp8l_cannonical_code(ctx, lencode_lengths,
        VP8L_LENCODE_LENGTHS, lencode, lencode_treemem);

    vp8l_byte_t lengths[VP8L_MAX_SYMBOLS];
    vp8l_code_word_t count = 0;

    for (vp8l_code_word_t i = 0, p = 8, s, c; count < size && i < limit; ++i) {
        switch (s = vp8l_code_read(ctx, lencode)) {
            default: case 0: {
                lengths[count++] = s;
            } continue;

            case  1: case  2: case  3: case  4: case  5:
            case  6: case  7: case  8: case  9: case 10:
            case 11: case 12: case 13: case 14: case 15: {
                lengths[count++] = p = s;
            } continue;

            case 16: s =  3 + ctx->read(2, ctx->u); c = p; break;
            case 17: s =  3 + ctx->read(3, ctx->u); c = 0; break;
            case 18: s = 11 + ctx->read(7, ctx->u); c = 0; break;
        }

        while (s--) lengths[count++] = c;
    }

    vp8l_cannonical_code(ctx, lengths, count, code, 0);
}

static inline void vp8l_code_decode(
    vp8l_context_t   ctx,
    vp8l_code_t      code,
    vp8l_code_word_t size) {

    ctx->read(1, ctx->u)
        ? vp8l_simple_code_decode(ctx, code)
        : vp8l_complex_code_decode(ctx, code, size);
}

static inline void vp8l_group_decode(
    vp8l_context_t ctx,
    vp8l_group_t   group,
    vp8l_byte_t    bits) {

    vp8l_code_word_t sizes[] = {
        (vp8l_code_word_t)(VP8L_LITLEN_COUNT + (bits ? 1 << bits : 0)),
        VP8L_LITERALS_COUNT, VP8L_LITERALS_COUNT, VP8L_LITERALS_COUNT,
        VP8L_DISTANCES_COUNT,
    };

    for (vp8l_byte_t i = 0; i < 5; ++i) {
        vp8l_code_decode(ctx, group->code + i, sizes[i]);
    }
}

/* /===========================================================================\
 * | GENERAL IMAGE DECODING                                                    |
 * \===========================================================================/
 */

static inline vp8l_size_t vp8l_lendst(vp8l_context_t ctx, vp8l_code_word_t c) {
    if (c < 4) return c;
    vp8l_size_t extra = (c - 2) >> 1;
    return ((2 + (c & 1)) << extra) + ctx->read(extra, ctx->u);
}

static inline vp8l_size_t vp8l_color_hash(vp8l_byte_t bits, vp8l_pixel_t c) {
    vp8l_size_t value = c.a << 24 | c.r << 16 | c.g << 8 | c.b;
    return ((0x1e35a7bd * value) & 0xFFFFFFFF) >> (32 - bits);
}

static inline void vp8l_cache_put(
    vp8l_byte_t   bits,
    vp8l_pixel_t *cache,
    vp8l_pixel_t  color) {
    if (bits) cache[vp8l_color_hash(bits, color)] = color;
}

static vp8l_pixel_t *vp8l_decode_image(
    vp8l_context_t ctx,
    vp8l_byte_t    main,
    vp8l_pixel_t  *storage,
    vp8l_size_t    w,
    vp8l_size_t    h) {

    vp8l_pixel_t *image = storage ? storage
        : (vp8l_pixel_t*) ctx->alloc(w * h * sizeof(vp8l_pixel_t), ctx->u);

    vp8l_byte_t cbits = ctx->read(1, ctx->u) ? ctx->read(4, ctx->u) : 0;
    vp8l_pixel_t *cache = cbits ? (vp8l_pixel_t*)
        ctx->alloc(sizeof(vp8l_pixel_t) * (1 << cbits), ctx->u) : 0;

    if (cbits) for (vp8l_size_t i = 0, c = 1 << cbits; i < c; ++i) {
        cache[i] = (vp8l_pixel_t) {0};
    }

    vp8l_size_t   group_count    = 1;
    vp8l_byte_t   entropy_bits   = 0;
    vp8l_size_t   entropy_stride = 0;
    vp8l_pixel_t *entropy        = 0;

    if (main && ctx->read(1, ctx->u)) {
        entropy_bits = ctx->read(3, ctx->u) + 2;

        vp8l_size_t block_mask = (1 << entropy_bits) - 1;
        vp8l_size_t ew = (w + block_mask) >> entropy_bits;
        vp8l_size_t eh = (h + block_mask) >> entropy_bits;

        entropy_stride = ew;

        vp8l_pixel_t *ep = entropy = vp8l_decode_image(ctx, 0, 0, ew, eh);
        for (vp8l_size_t i = 0, s = ew * eh; i < s; ++i, ++ep) {
            vp8l_size_t group = ep->r << 8 | ep->g;
            if (group_count <= group) group_count = group + 1;
        }
    }

    struct vp8l_group single_group, *groups = group_count > 1 ? (vp8l_group_t)
        ctx->alloc(sizeof(struct vp8l_group) * group_count, ctx->u)
        : &single_group;

    for (vp8l_size_t i = 0; i < group_count; ++i) {
        vp8l_group_decode(ctx, groups + i, cbits);
    }

    for (vp8l_pixel_t *pixel = image, *end = image + w * h; pixel < end;) {
        vp8l_group_t g = groups;

        if (entropy) {
            vp8l_size_t
                offset = pixel - image,
                ex = (offset % w) >> entropy_bits,
                ey = (offset / w) >> entropy_bits;
            vp8l_pixel_t *ep = entropy + entropy_stride * ey + ex;
            g += (ep->r << 8 | ep->g);
        }

        vp8l_code_word_t code = vp8l_code_read(ctx, g->code + 0);

        if (code < VP8L_LITERALS_COUNT) {
            vp8l_byte_t r = vp8l_code_read(ctx, g->code + 1);
            vp8l_byte_t b = vp8l_code_read(ctx, g->code + 2);
            vp8l_byte_t a = vp8l_code_read(ctx, g->code + 3);
            vp8l_pixel_t color = { r, (vp8l_byte_t) code, b, a };
            vp8l_cache_put(cbits, cache, *pixel++ = color);
        } else if (code < VP8L_LITLEN_COUNT) {
            vp8l_size_t
                length   = vp8l_lendst(ctx, code - VP8L_LITERALS_COUNT),
                distcode = vp8l_code_read(ctx, g->code + 4),
                distance = vp8l_lendst(ctx, distcode);

            vp8l_diff_t offset = distance < VP8L_OFFSET_COUNT
                ? vp8l_offsets[distance][0] + vp8l_offsets[distance][1] * w
                : distance - VP8L_OFFSET_COUNT + 1;

            offset = offset < 1 ? 1 : offset;

            for (vp8l_size_t i = 0; i <= length; ++i, ++pixel) {
                vp8l_cache_put(cbits, cache, *pixel = pixel[-offset]);
            }
        } else *pixel++ = cache[code - VP8L_LITLEN_COUNT];
    }

    vp8l_code_node_t *tree;
    for (vp8l_size_t i = 0; i < group_count; ++i) {
        for (vp8l_byte_t j = 0; j < 5; ++j) {
            if ((tree = groups[i].code[j].tree))
                ctx->free(tree, ctx->u);
        }
    }

    if (group_count > 1) ctx->free(groups, ctx->u);
    if (entropy) ctx->free(entropy, ctx->u);
    if (cache) ctx->free(cache, ctx->u);
    return image;
}

#if !defined(WHALE_DISABLE_PREDICTOR_TRANSFORM) ||\
    !defined(WHALE_DISABLE_COLOR_TRANSFORM)

static vp8l_byte_t vp8l_block_image_decode(
    vp8l_context_t ctx,
    vp8l_size_t    w,
    vp8l_size_t    h,
    vp8l_pixel_t **data) {

    vp8l_byte_t bits = ctx->read(3, ctx->u) + 2;

    vp8l_size_t block_mask = (1 << bits) - 1;
    vp8l_size_t data_w = (w + block_mask) >> bits;
    vp8l_size_t data_h = (h + block_mask) >> bits;

    return *data = vp8l_decode_image(ctx, 0, 0, data_w, data_h), bits;
}

#endif

/* /===========================================================================\
 * | PREDICTOR TRANSFORM                                                       |
 * \===========================================================================/
 */

#ifndef WHALE_DISABLE_PREDICTOR_TRANSFORM

static inline vp8l_diff_t vp8l_abs(vp8l_diff_t a) {
    return a >= 0 ? a : -a;
}

static inline vp8l_byte_t vp8l_clamp(vp8l_diff_t a) {
    return a < 0 ? 0 : a > 255 ? 255 : a;
}

static inline vp8l_byte_t vp8l_sub_half(vp8l_diff_t a, vp8l_diff_t b) {
    return vp8l_clamp(a + (a - b) / 2);
}

static void vp8l_apply_predictor(
    vp8l_byte_t   t,
    vp8l_pixel_t *p,
    vp8l_pixel_t *a,
    vp8l_pixel_t *b,
    vp8l_pixel_t *c,
    vp8l_pixel_t *d) {

    vp8l_pixel_t *x, *y;

    switch (t) {
        case 0: p->a += 255; break;

        case 1: x = a; goto add;
        case 2: x = c; goto add;
        case 3: x = d; goto add;
        case 4: x = b; goto add;

        add: {
            p->r += x->r;
            p->g += x->g;
            p->b += x->b;
            p->a += x->a;
        } break;

        case 5: {
            p->r += (((a->r + d->r) >> 1) + c->r) >> 1;
            p->g += (((a->g + d->g) >> 1) + c->g) >> 1;
            p->b += (((a->b + d->b) >> 1) + c->b) >> 1;
            p->a += (((a->a + d->a) >> 1) + c->a) >> 1;
        } break;

        case 6: x = a; y = b; goto avg;
        case 7: x = a; y = c; goto avg;
        case 8: x = c; y = b; goto avg;
        case 9: x = c; y = d; goto avg;

        avg: {
            p->r += (x->r + y->r) >> 1;
            p->g += (x->g + y->g) >> 1;
            p->b += (x->b + y->b) >> 1;
            p->a += (x->a + y->a) >> 1;
        } break;

        case 10: {
            p->r += (((a->r + b->r) >> 1) + ((c->r + d->r) >> 1)) >> 1;
            p->g += (((a->g + b->g) >> 1) + ((c->g + d->g) >> 1)) >> 1;
            p->b += (((a->b + b->b) >> 1) + ((c->b + d->b) >> 1)) >> 1;
            p->a += (((a->a + b->a) >> 1) + ((c->a + d->a) >> 1)) >> 1;
        } break;

        case 11: {
             vp8l_diff_t m =
                vp8l_abs(a->r - b->r) - vp8l_abs(c->r - b->r) +
                vp8l_abs(a->g - b->g) - vp8l_abs(c->g - b->g) +
                vp8l_abs(a->b - b->b) - vp8l_abs(c->b - b->b) +
                vp8l_abs(a->a - b->a) - vp8l_abs(c->a - b->a) ;

            p->r += (m > 0 ? a->r : c->r);
            p->g += (m > 0 ? a->g : c->g);
            p->b += (m > 0 ? a->b : c->b);
            p->a += (m > 0 ? a->a : c->a);
        } break;

        case 12: {
            p->r += vp8l_clamp(a->r + c->r - b->r);
            p->g += vp8l_clamp(a->g + c->g - b->g);
            p->b += vp8l_clamp(a->b + c->b - b->b);
            p->a += vp8l_clamp(a->a + c->a - b->a);
        } break;

        case 13: {
            p->r += vp8l_sub_half((a->r + c->r) >> 1, b->r);
            p->g += vp8l_sub_half((a->g + c->g) >> 1, b->g);
            p->b += vp8l_sub_half((a->b + c->b) >> 1, b->b);
            p->a += vp8l_sub_half((a->a + c->a) >> 1, b->a);
        } break;
    }
}

static void vp8l_apply_transform_predictor(
    vp8l_pixel_t *px,
    vp8l_size_t   w,
    vp8l_size_t   h,
    vp8l_byte_t   bits,
    vp8l_pixel_t *data) {

    for (vp8l_size_t c = (w + (1 << bits) - 1) >> bits, y = 0; y < h; ++y) {
        for (vp8l_size_t x = 0; x < w; ++x, ++px) {
            vp8l_apply_predictor(x
                ? (y ? data[((y >> bits) * c + (x >> bits))].g : 1)
                : !!y << 1, px, px - 1, px - w - 1, px - w, px - w + 1);
        }
    }
}

#endif

/* /===========================================================================\
 * | COLOR TRANSFORM                                                           |
 * \===========================================================================/
 */

#ifndef WHALE_DISABLE_COLOR_TRANSFORM

static inline vp8l_byte_t vp8l_color_delta(vp8l_byte_t c1, vp8l_byte_t c2) {
    vp8l_diff_t sc1 = c1 >= 128 ? -256 + c1 : c1;
    vp8l_diff_t sc2 = c2 >= 128 ? -256 + c2 : c2;
    return (sc1 * sc2) >> 5;
}

static void vp8l_apply_transform_color(
    vp8l_pixel_t *image,
    vp8l_size_t   w,
    vp8l_size_t   h,
    vp8l_byte_t   bits,
    vp8l_pixel_t *color) {

    for (vp8l_size_t c = (w + (1 << bits) - 1) >> bits, y = 0; y < h; ++y) {
        vp8l_pixel_t *line = color + (y >> bits) * c;
        for (vp8l_size_t x = 0; x < w; ++x, ++image) {
            vp8l_pixel_t cpx = line[x >> bits];
            image->r += vp8l_color_delta(cpx.b, image->g);
            image->b += vp8l_color_delta(cpx.g, image->g)
                    + vp8l_color_delta(cpx.r, image->r);
        }
    }
}

#endif

/* /===========================================================================\
 * | SUBTRACT GREEN TRANSFORM                                                  |
 * \===========================================================================/
 */

#ifndef WHALE_DISABLE_SUBTRACT_GREEN_TRANSFORM

static void vp8l_apply_transform_green(vp8l_pixel_t *img, vp8l_size_t size) {
    for (vp8l_pixel_t *px = img, *e = px + size; px < e; ++px) {
        px->r += px->g, px->b += px->g;
    }
}

#endif

/* /===========================================================================\
 * | INDEX TRANSFORM                                                           |
 * \===========================================================================/
 */

#ifndef WHALE_DISABLE_INDEX_TRANSFORM

static inline vp8l_byte_t vp8l_transform_index_reduction(vp8l_byte_t size) {
    switch (size >> 1) {
        default: return 0; case 0: return 3; case 1: return 2;
        case 2: case 3: case 4: case 5: case 6: case 7: return 1;
    }
}

static vp8l_byte_t vp8l_transform_index(vp8l_context_t ctx, vp8l_pixel_t **o) {
    vp8l_byte_t c = ctx->read(8, ctx->u);
    vp8l_pixel_t *img = vp8l_decode_image(ctx, 0, 0, c + 1, 1), p = {0};

    for (vp8l_pixel_t *px = img + 1, *e = px + c; px < e; p = *px++) {
        px->r += p.r, px->g += p.g, px->b += p.b, px->a += p.a;
    } return *o = img, c;
}

static void vp8l_apply_transform_index(
    vp8l_pixel_t *image,
    vp8l_size_t   fullw,
    vp8l_size_t   h,
    vp8l_byte_t   size,
    vp8l_pixel_t *index) {

    vp8l_byte_t bits = vp8l_transform_index_reduction(size);
    vp8l_size_t stride = fullw >> bits;
    vp8l_pixel_t *px = image + fullw * h, *l = image + stride * h;
    vp8l_byte_t
        mask = (1 << (8 >> bits)) - 1,
        mod  = (1 << bits) - 1,
        rb   = 3 - bits;

    for (vp8l_size_t y = h; l -= stride, y; --y) {
        for (vp8l_size_t x = fullw; x--;) {
            vp8l_byte_t i = (l[x >> bits].g >> ((x & mod) << rb)) & mask;
            *--px = (i <= size ? index[i] : (vp8l_pixel_t) {0});
        }
    }
}

#endif

/* /===========================================================================\
 * | ENTRY POINT                                                               |
 * \===========================================================================/
 */

static void *vp8l_decode_context(
    vp8l_context_t ctx,
    unsigned int  *width,
    unsigned int  *height) {

    vp8l_size_t w = ctx->read(14, ctx->u) + 1, fullw = w;
    vp8l_size_t h = ctx->read(14, ctx->u) + 1;

    if (width)  *width  = (unsigned int) w;
    if (height) *height = (unsigned int) h;

    ctx->read(4, ctx->u);

    vp8l_pixel_t *rgba = (vp8l_pixel_t*) ctx->alloc(w * h * 4, ctx->u);

    vp8l_byte_t list = 0, count = 0, t;

    #ifndef WHALE_DISABLE_PREDICTOR_TRANSFORM
    vp8l_byte_t predictor_bits = 0; vp8l_pixel_t *predictor = 0;
    #endif

    #ifndef WHALE_DISABLE_COLOR_TRANSFORM
    vp8l_byte_t color_bits = 0; vp8l_pixel_t *color = 0;
    #endif

    #ifndef WHALE_DISABLE_INDEX_TRANSFORM
    vp8l_byte_t index_size = 0; vp8l_pixel_t *index = 0;
    #endif

    while (ctx->read(1, ctx->u)) switch (t = ctx->read(2, ctx->u)) {
        #ifndef WHALE_DISABLE_PREDICTOR_TRANSFORM
        case VP8L_TRANSFORM_PREDICTOR:
            predictor_bits = vp8l_block_image_decode(ctx, w, h, &predictor);
            goto append;
        #endif

        #ifndef WHALE_DISABLE_COLOR_TRANSFORM
        case VP8L_TRANSFORM_COLOR:
            color_bits = vp8l_block_image_decode(ctx, w, h, &color);
            goto append;
        #endif

        #ifndef WHALE_DISABLE_SUBTRACT_GREEN_TRANSFORM
        case VP8L_TRANSFORM_GREEN:
            goto append;
        #endif

        #ifndef WHALE_DISABLE_INDEX_TRANSFORM
        case VP8L_TRANSFORM_INDEX:
            index_size = vp8l_transform_index(ctx, &index);
            w >>= vp8l_transform_index_reduction(index_size);
            goto append;
        #endif

        append: list = (list << 2) | t;
        default: ++count; break;
    }

    vp8l_decode_image(ctx, 1, rgba, w, h);

    for (vp8l_byte_t i = 0; i < count; ++i, list >>= 2) switch (list & 3) {
        #ifndef WHALE_DISABLE_PREDICTOR_TRANSFORM
        case VP8L_TRANSFORM_PREDICTOR: vp8l_apply_transform_predictor(
            rgba, w, h, predictor_bits, predictor); break;
        #endif

        #ifndef WHALE_DISABLE_COLOR_TRANSFORM
        case VP8L_TRANSFORM_COLOR: vp8l_apply_transform_color(
            rgba, w, h, color_bits, color); break;
        #endif

        #ifndef WHALE_DISABLE_SUBTRACT_GREEN_TRANSFORM
        case VP8L_TRANSFORM_GREEN: vp8l_apply_transform_green(
            rgba, w * h); break;
        #endif

        #ifndef WHALE_DISABLE_INDEX_TRANSFORM
        case VP8L_TRANSFORM_INDEX: vp8l_apply_transform_index(
            rgba, w = fullw, h, index_size, index); break;
        #endif
    }

    #ifndef WHALE_DISABLE_PREDICTOR_TRANSFORM
    if (predictor) ctx->free(predictor, ctx->u);
    #endif

    #ifndef WHALE_DISABLE_COLOR_TRANSFORM
    if (color) ctx->free(color, ctx->u);
    #endif

    #ifndef WHALE_DISABLE_INDEX_TRANSFORM
    if (index) ctx->free(index, ctx->u);
    #endif

    return rgba;
}

void *whale_decode(
    void           *user_data,
    unsigned long (*stream) (unsigned char n, void *user_data),
    void*         (*alloc)  (unsigned long n, void *user_data),
    void          (*free)   (void     *block, void *user_data),
    unsigned int   *width,
    unsigned int   *height) {

    struct vp8l_context ctx = { user_data, stream, alloc, free };
    return vp8l_decode_context(&ctx, width, height);
}

#ifdef __cplusplus
}
#endif
